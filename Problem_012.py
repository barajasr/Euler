#! usr/bin/env python
# -*- coding: iso-8859-15 -*-

# Problem 12: Highly divisible triangular number
#--------------------------------------------------------------------
# The sequence of triangle numbers is generated by adding the
# natural numbers. So the 7th number would be Σa, where a = [1...7],
# or 28. The first ten terms would be:
#   1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
# Let us list the factors of the first seven triangle numbers:
#    1: 1
#    3: 1,3
#    6: 1,2,3,6
#   10: 1,2,5,10
#   15: 1,3,5,15
#   21: 1,3,7,21
#   28: 1,2,4,7,14,28
# We can see that 28 is the first triangle number to have over five
# divisors.
#
# What is the value of the first triangle number to have over five
# hundred divisors?
#--------------------------------------------------------------------

import math

primes = {1:2, 2:3, 3:5}

def genPrimes(value, inclusive=False):
    if not inclusive:
        upTo = math.floor(math.sqrt(value))+1
    else:
        upTo = value
    # Pk = (6k±1)/2
    end = len(primes)+1
    k = (primes[end-1]-1)/6 + 1
    pK = 6*k-1
    while pK <= upTo:
        if isPrime(pK):
            primes[end] = pK
            end +=1
        if isPrime(pK+2):
            primes[end] = pK+2
            end += 1
        k += 1
        pK = 6*k-1

# Create a list l of consecutive integers {2,3,…,N}.
# Select p as the first prime number in the list, p=2.
# Remove all multiples of p from the l.
# set p equal to the next integer in l which has not been removed.
# Repeat steps 3 and 4 until p2 > N, all the remaining numbers in the list are primes
def genPrimesESieve(limit, inclusive=False):
    sieveBound = (limit-1) / 2 if not inclusive else limit
    upperSqrt = (int(math.sqrt(limit)) - 1) / 2;
    primeBits = [True for i in xrange(sieveBound+1)]

    key = 1
    for i in xrange(2, sieveBound+1):
        if primeBits[i]:
            primes[key] = i
            key += 1
            j = i*2
            while j <= sieveBound:
                primeBits[j] = False
                j += i

def isPrime(value):
    if value <= 1: return False

    key, end = 1, len(primes)
    while key <= end and primes[key] <= value:
        if value == primes[key]:
            return True
        elif value%primes[key] == 0:
            return False
        key += 1
    return False

def numOfFactors(number):
    factors = 1
    found = False
    for prime in primes.values():
        if prime > number or found: break
        exp = 1
        value = prime**exp
        if number%value == 0:
            while number%value == 0:
                if value == number: found = True
                exp +=1
                value *= prime
            factors *= exp
    return factors

# 0m0.437s, with maxN=1000 and no genPrimes() call at top
# of numOfFactors, 0m2.175s otherwise
def main():
    maxN = 1000
    maxTriangle = (maxN*(maxN+1)/2)
    genPrimes(maxTriangle)
    triangleNumber, number = (1, 1)
    done = False
    while not done:
        number += 1
        triangleNumber += number
        length = numOfFactors(triangleNumber)
        if length > 500:
            done = True
    print 'First triangle number to have over 500 divisors:'
    print number, triangleNumber, length

if __name__ == '__main__':
    main()

